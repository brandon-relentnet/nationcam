// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: videos.sql

package db

import (
	"context"
	"time"
)

const createVideo = `-- name: CreateVideo :one
INSERT INTO videos (title, src, type, state_id, sublocation_id, status, created_by)
VALUES ($1, $2, $3, $4, $5, $6, $7)
RETURNING video_id, title, src, type, state_id, sublocation_id, status, created_by, created_at, updated_at
`

type CreateVideoParams struct {
	Title         string `json:"title"`
	Src           string `json:"src"`
	Type          string `json:"type"`
	StateID       int32  `json:"state_id"`
	SublocationID *int32 `json:"sublocation_id"`
	Status        string `json:"status"`
	CreatedBy     string `json:"created_by"`
}

func (q *Queries) CreateVideo(ctx context.Context, arg CreateVideoParams) (Video, error) {
	row := q.db.QueryRow(ctx, createVideo,
		arg.Title,
		arg.Src,
		arg.Type,
		arg.StateID,
		arg.SublocationID,
		arg.Status,
		arg.CreatedBy,
	)
	var i Video
	err := row.Scan(
		&i.VideoID,
		&i.Title,
		&i.Src,
		&i.Type,
		&i.StateID,
		&i.SublocationID,
		&i.Status,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listVideos = `-- name: ListVideos :many
SELECT v.video_id, v.title, v.src, v.type, v.state_id, v.sublocation_id,
       v.status, v.created_by, v.created_at, v.updated_at,
       s.name AS state_name,
       COALESCE(sub.name, '') AS sublocation_name
FROM videos v
JOIN states s ON s.state_id = v.state_id
LEFT JOIN sublocations sub ON sub.sublocation_id = v.sublocation_id
WHERE v.status = 'active'
ORDER BY v.title
`

type ListVideosRow struct {
	VideoID         int32     `json:"video_id"`
	Title           string    `json:"title"`
	Src             string    `json:"src"`
	Type            string    `json:"type"`
	StateID         int32     `json:"state_id"`
	SublocationID   *int32    `json:"sublocation_id"`
	Status          string    `json:"status"`
	CreatedBy       string    `json:"created_by"`
	CreatedAt       time.Time `json:"created_at"`
	UpdatedAt       time.Time `json:"updated_at"`
	StateName       string    `json:"state_name"`
	SublocationName string    `json:"sublocation_name"`
}

func (q *Queries) ListVideos(ctx context.Context) ([]ListVideosRow, error) {
	rows, err := q.db.Query(ctx, listVideos)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListVideosRow{}
	for rows.Next() {
		var i ListVideosRow
		if err := rows.Scan(
			&i.VideoID,
			&i.Title,
			&i.Src,
			&i.Type,
			&i.StateID,
			&i.SublocationID,
			&i.Status,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.StateName,
			&i.SublocationName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listVideosByState = `-- name: ListVideosByState :many
SELECT v.video_id, v.title, v.src, v.type, v.state_id, v.sublocation_id,
       v.status, v.created_by, v.created_at, v.updated_at,
       s.name AS state_name,
       COALESCE(sub.name, '') AS sublocation_name
FROM videos v
JOIN states s ON s.state_id = v.state_id
LEFT JOIN sublocations sub ON sub.sublocation_id = v.sublocation_id
WHERE v.state_id = $1 AND v.status = 'active'
ORDER BY v.title
`

type ListVideosByStateRow struct {
	VideoID         int32     `json:"video_id"`
	Title           string    `json:"title"`
	Src             string    `json:"src"`
	Type            string    `json:"type"`
	StateID         int32     `json:"state_id"`
	SublocationID   *int32    `json:"sublocation_id"`
	Status          string    `json:"status"`
	CreatedBy       string    `json:"created_by"`
	CreatedAt       time.Time `json:"created_at"`
	UpdatedAt       time.Time `json:"updated_at"`
	StateName       string    `json:"state_name"`
	SublocationName string    `json:"sublocation_name"`
}

func (q *Queries) ListVideosByState(ctx context.Context, stateID int32) ([]ListVideosByStateRow, error) {
	rows, err := q.db.Query(ctx, listVideosByState, stateID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListVideosByStateRow{}
	for rows.Next() {
		var i ListVideosByStateRow
		if err := rows.Scan(
			&i.VideoID,
			&i.Title,
			&i.Src,
			&i.Type,
			&i.StateID,
			&i.SublocationID,
			&i.Status,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.StateName,
			&i.SublocationName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listVideosBySublocation = `-- name: ListVideosBySublocation :many
SELECT v.video_id, v.title, v.src, v.type, v.state_id, v.sublocation_id,
       v.status, v.created_by, v.created_at, v.updated_at,
       s.name AS state_name,
       COALESCE(sub.name, '') AS sublocation_name
FROM videos v
JOIN states s ON s.state_id = v.state_id
LEFT JOIN sublocations sub ON sub.sublocation_id = v.sublocation_id
WHERE v.sublocation_id = $1 AND v.status = 'active'
ORDER BY v.title
`

type ListVideosBySublocationRow struct {
	VideoID         int32     `json:"video_id"`
	Title           string    `json:"title"`
	Src             string    `json:"src"`
	Type            string    `json:"type"`
	StateID         int32     `json:"state_id"`
	SublocationID   *int32    `json:"sublocation_id"`
	Status          string    `json:"status"`
	CreatedBy       string    `json:"created_by"`
	CreatedAt       time.Time `json:"created_at"`
	UpdatedAt       time.Time `json:"updated_at"`
	StateName       string    `json:"state_name"`
	SublocationName string    `json:"sublocation_name"`
}

func (q *Queries) ListVideosBySublocation(ctx context.Context, sublocationID *int32) ([]ListVideosBySublocationRow, error) {
	rows, err := q.db.Query(ctx, listVideosBySublocation, sublocationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListVideosBySublocationRow{}
	for rows.Next() {
		var i ListVideosBySublocationRow
		if err := rows.Scan(
			&i.VideoID,
			&i.Title,
			&i.Src,
			&i.Type,
			&i.StateID,
			&i.SublocationID,
			&i.Status,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.StateName,
			&i.SublocationName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
